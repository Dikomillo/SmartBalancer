# Сравнение `example_only` и SmartFilter

## Как работает `example_only`
- Контроллер сразу решает задачу: поиск названия, выбор ссылок на фильмы и разветвление на фильмы/сериалы без промежуточных абстракций.
- Для сериалов контроллер запрашивает пагинацию и строит шаблоны `SeasonTpl` и `EpisodeTpl` напрямую из списка эпизодов. Любой сезон превращается в ссылку на `/uaflix` с параметрами, эпизоды — в готовые вызовы `play`.
- Пайплайн короткий: `Controller.Index` → `UaflixInvoke.Search/GetPaginationInfo` → заполнение шаблонов → HTML/JSON. Тут нет промежуточной нормализации: если сайт вернул season/episode, оно сразу попадает в ответ Лампы.

## Как построен SmartFilter
- Контроллер `SmartFilterController` передаёт управление `SmartFilterEngine`, который пытается агрегировать данные со всех доступных провайдеров, не зная заранее их формат. Для сериалов он сначала строит `AggregationResult` с типом `season`/`episode`, потом через `BuildSeasonPayload`/`BuildEpisodePayload` собирает выходной JSON/HTML.
- На пути к результату движок делает много шагов: собирает список провайдеров, параллельно тянет их API, нормализует поля, отбрасывает дубликаты, вычисляет озвучки, качество и т.п. Лишь после этого он конструирует `SeasonTpl`/`EpisodeTpl`. Любое несоответствие формату (нет `url`, неполные поля `season`/`episode`, необычный вид озвучки) приводит к тому, что эпизод просто не попадёт в итоговую коллекцию.

## Почему `example_only` стабильно показывает сериалы
`example_only` знает, как именно выглядит сайт Uaflix: парсит HTML, вытаскивает сезон/эпизод через regex и сразу делает ссылки. Нет лишних проверок или объединения с другими источниками, поэтому эпизод отображается, пока сайт отдаёт ожидаемую верстку.

SmartFilter, напротив, пытается быть универсальным. Он фильтрует данные и требует строгой структуры. Для сериалов это особенно критично: если какой-то провайдер возвращает озвучки или сезоны иначе (другие имена свойств, набор ссылок), нормализация (`NormalizeSeasonItem`, `NormalizeEpisodeItem`) завершается неуспехом и эпизод/сезон не попадает в выдачу. Снаружи это выглядит как «сложная логика», а пользователь получает пустой список.

## Что можно сделать
1. **Добавить адаптеры под конкретных провайдеров.** Перед тем как отдавать данные в SmartFilterEngine, преобразовывать ответ провайдера к ожидаемой структуре (те самые `url`, `season`, `episode`, `voice`). Это снимет необходимость гадать внутри движка, что имел в виду конкретный сервис, и уменьшит число отфильтрованных элементов.
2. **Сделать упрощённый сценарий.** Если активен только один провайдер — использовать прямой рендер по образцу `example_only` (сразу строить `SeasonTpl`/`EpisodeTpl`), минуя агрегатор. Это обеспечит «план Б» для провайдеров с нестандартной структурой.
3. **Логирование и диагностика.** Логировать причины, по которым `NormalizeSeasonItem`/`NormalizeEpisodeItem` возвращают `false`. Это позволит увидеть конкретные поля, из-за которых элементы отбрасываются, и решить, нужно ли ослабить требования.
4. **Конфигурация фильтров.** Позволить отключать определённые «умные» шаги (например, объединение дублей по сезону/эпизоду или агрессивную фильтрацию озвучек) для конкретных провайдеров, если они ломают выдачу.
5. **Юнит-тесты на реальные JSON-ответы.** Сохранить примеры ответов проблемных провайдеров и написать тесты на `BuildSeasonPayload`/`BuildEpisodePayload`, чтобы увидеть, где данные теряются.

Такой подход сохраняет гибкость SmartFilter, но обеспечивает предсказуемость, которой достигает `example_only` за счёт минимальной логики.
